### pushq %rbp
入栈指令.将寄存器 %rbp 现在的值放入堆栈中.
执行步骤:
* rsp会-8
* 然后设置内存地址为 rsp 的内存的值为 %rbp的值. (8字节赋值)

### popq %rbp
出栈指令.从堆栈中取出一个值,并且赋值给 %rbp
执行步骤:
* 设置 rbp 的值为 [rsp] 的值.
* rsp会+8

### movl $0x0, -0x4(%rbp) 
4字节赋值指令.
* 把 内存地址为 rbp-4 的内存,赋值为0.
* 只修改那个内存地址向后的4个字节.

### retq
函数返回指令.
* pc = *rsp (把rsp的值指向的内存地址取出来,赋值给pc)
* rsp+=8 (rsp自加8)

### callq 0x7fff8ea1a5fc
函数调用指令
* rsp-=8
* *rsp= callq的下一条指令的开始位置 
* pc=0x7fff8ea1a5fc

### 说明
* 汇编机器执行时有 一个包含 内存和寄存器 的上下文.
* 每一条汇编指令就是修改这些上下文信息.
* push pop ret call 等本身包含一些含义,但是它们也是对 内存和寄存器的上下文 的修改.
* 机器只会按照指令执行,指令没有涉及到的地方不需要关心.
* pc的值表示下一条指令的执行位置.
* rsp的值表示堆栈的顶部位置(这个值自己里面是最顶部的数据.)